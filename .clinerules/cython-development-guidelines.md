## 简要概述
这份文件包含了与Cython开发相关的指导方针和偏好。主要目标是在保证代码正确性和一定精度的情况下，将计算密集型的Python代码（如Numpy, Numba JIT）转换为高效的Cython代码。

## 沟通风格
-   将我（用户）视为一个有经验的Python开发者，但只是一个Cython和C语言的初学者。
-   在进行代码更改时，请向我解释这些更改，特别是当涉及到复杂的C语言特性或Cython特有的语法时。

## Cython 编码规范
-   **Cython的本质**: 尽管拥有许多C的特性，但Cython本质上是Python的超集，而不是C的超集。在编写代码时，务必注意Cython本身的限制，它不拥有全部的C特性。
-   **内联函数**: 使用 `cdef inline return_type func_name()` 的语法来定义内联函数，而不是 `cdef static inline ...`。
-   **数组定义**: 可以使用`cdef int[4] g = [1, 2, 3, 4]`来定义数组，这种Java-style的写法是被推荐的，而`cdef int g[4]`这种C-style的写法被弃用了。
-   **`nogil` 和 `prange` 块**:
    -   不要在 `with nogil` 或 `prange` 块内部使用 `cdef` 声明变量。所有变量必须在块外部提前声明。
    -   在`nogil`函数内部，可以声明一般C变量，但不能声明Python对象，如利用np.empty初始化memoryview。这些memoryview应该在Python`def`类型的函数中声明好，然后传入nogil标记的`cdef`C类型函数。
    -   在 `prange` 循环中，通过在循环外声明并在循环内使用非原地操作（non-in-place operation）赋值来创建私有变量。
    -   注意区分私有变量和规约变量（reduction variable）。原地赋值操作会将变量视为规约变量，这可能导致编译错误。
    -   如果需要更灵活的内存操作，可以在 `prange` 外部声明指针，在循环内部为其分配内存。使用此方法时必须确保逻辑正确性。
-   **`const`和`volatile` 限定符**: 
    -   在Cython中，`const`主要用于函数签名中，此时使用和C类似。如`cdef void pointer_to_const_int(const int* value)`定义了一个不可变指针指向可变值；
    -   不应在函数体中定义`const`变量为运行时依赖于其他变量的值（如函数中书写`cdef const inv_x = 1.0 / x`是不被允许的，因为依赖`x`的取值）。
-   **浮点数字面量**: 必须显式指定类型，例如 `<float>4.0`，而不是使用C风格的 `4.0f`。
-   **语法风格**:
    -   当Cython提供Python风格和C风格的两种语法时（例如 `@cython.inline` vs `cdef inline`），优先选择字面上更容易理解、且与上下文匹配的写法。
    -   如果使用了复杂的C风格语法，请向我解释其工作原理，并简要介绍可能存在的Python风格替代方案。

## 代码优化策略
-   **优化顺序**: 严格遵循以下优化顺序：
    1.  **算法优化**: 首先确保使用的是最高效的算法。
    2.  **计算效率优化**: 关注SIMD（单指令多数据流）和优内存局部性（memory locality）化。
    3.  **OpenMP多线程优化**: 在前两步优化到满意程度后，最后再考虑使用OpenMP进行并行化。
-   **增量优化**:
    -   可以顺手进行一些细节优化，例如通过声明字面量类型来防止不必要的隐式类型提升。
-   **分支优化**: 关于分支（if/else）的优化，你可以根据自己的专业知识做出判断。
-   **最终目标**: 所有优化的核心目标是在保证代码正确性和可接受精度的情况下，最大化提升代码的运行效率。
